# [3주차] Backtracking & DFS 알고리즘

***

## 🎯 목표

* 목표

---

## 🔄️ Backtracking & DFS 알고리즘

- 알고리즘

---

### 🎯 [BOJ_10974] 모든 순열

---

#### 👉 접근법

- 백트래킹의 가장 기본적인 문제라 생각이 들었다.
- 백트래킹 알고리즘을 통째로 외웠기 때문에.. 그냥 구현했다..
- 해당 알고리즘은 방문 여부를 on/off 하면서 depth 로 들어가기 때문에 중복없이 출력이 가능하다
- 아 그리고 이게 백트래킹인지 이제 처음 알았다 (백준의 N과 M 시리즈를 풀었는데 백트래킹인지 모르고 풀었음..ㅋㅋ)

#### ⏳ 시간복잡도

- 중복없는 순열이 조건이기 때문에 O(n!)이라 생각이 듭니다

![10974](https://github.com/DoYouKnowAlgorithm/Class1/assets/110602069/ebcd2594-a5d0-42ad-98ed-3fd8aca7974a)

#

### 🎯 [BOJ_10971] 외판원 순회 2

---

#### 👉 접근법

- 맨 처음에 문제를 이해하지 못 했다..(하얀좌의 도움으로 해결)
- 문제를 해석보자면 이렇다
- 도시의 수(N)을 주면 N까지의 순열을 찾은 후
- 가장 최소 비용을 출력하면 된다
- ex) N = 3 이라면
- 1 2 3 / 1 3 2 / 2 1 3 / 2 3 1 / 3 1 2 / 3 2 1
- 이렇게 6가지의 경우의 수가 나오고 항상 마지막은
- 출발점으로 돌아가야 순회가 완료된다.
- 1 2 3 1 / 1 3 2 1 / 2 1 3 2 / 2 3 1 2 / 3 1 2 3 / 3 2 1 3
- 즉 순회해야하는 모든 경우의 수는 위와 같으면 각각의 비용을 모두 합산하여
- 최소 비용을 출력하면 된다.
- 여기서 주의할 점은 만약 비용이 0이라면 '갈 수 없는 경우'이기 때문에
- 계산에서 제외해줘야 한다

#### ⏳ 시간복잡도

- N 개의 모든 도시를 탐색하는 경우의 수는 O(N!)
- 비용을 계산하는 시간 O(N)
- O(N+N!)??..

![10971](https://github.com/DoYouKnowAlgorithm/Class1/assets/110602069/af65aaca-7d64-4c5a-9d08-9296878a377c)


<br>
<br>
<br>
<br>

### 🎯 [BOJ_11123] 양 한마리... 양 두마리...

---

#### 👉 접근법

- DFS 의 가장 기본적인 문제라 생각이 들어 테스트 케이스별로 양(#)을 카운트 한다음에
- 결과를 출력하기로 했다
- 양(#)을 카운트하는 방법은 DFS 로 카운트하기 때문에
- 한 번 DFS 에 들어가면 재귀적으로 상,하,좌,우로 양(#)이 있는지 탐색하였고
- 양이 없거나 방문하지 않았다면 종료하는 식으로 구현하였다
- 한 마디로 DFS를 몇 번 탐색하게 되었냐가 곧 정답이라 생각한다

#### ⏳ 시간복잡도

- 모든 테스트 케이스(100개) 전부가 양이 단 한 마리도 없는
- 경우의 수가 최악이라 생각하므로 O(T*n^2)이라 생각한다

#

### 🎯 [BOJ_17265] 나의 인생에는 수학과 함께

---

#### 👉 접근법

- N의 크기가 작고 (3 아니면 5)
- 최단 경로를 구하는 힌트까지 주었다 (오른쪽 or 아래로 이동)
- 따라서 방문할 수 있는 모든 최단 경로를 구하였고
- 단순히 계산해주어 풀었다
- 초기 설정을 잘못해서 로직이 틀렸나 했었는데
- 초기에 설정을 잘 하자
- maxResult(최댓값) = Integer.MIN_VALUE (0으로 하면 틀림)
- minResult(최솟값) = Integer.MAX_VALUE

#### ⏳ 시간복잡도

- N의 모든 경로가 아닌 최단 경로만 찾고
- 해당 경로를 다시 for 문으로 돌립니다
- 그래서 시간복잡도는 !
