## 그리디 알고리즘

---

그리디 알고리즘이란 "**현재 상황에서 최적이라고 생각하는 해를 선택**"하는 방법이다.

말 그대로 현재 상황만 고려하기 때문에 항상 최적해를 보장하지 않는다.

그리디 알고리즘으로 최적해를 도출하기 위해서는 두 가지 조건을 만족해야 한다.

1. 탐욕적 선택 속성 (Greedy Choice Property)
2. 최적 부분 구조 (Optimal Substructure)

탐욕적 선택 속성이란 탐욕적인 선택이 항상 안전하다는 것이 보장된다는 의미이다.

예를 들어, 동전 거스름돈 문제를 생각해 볼 수 있다.
가장 큰 동전부터 차례대로 거슬러준다면 최적해가 보장된다.
물론, 동전의 단위가 모두 배수의 형태라는 가정 하에 적용된다.

최적 부분 구조란 부분 최적해들이 모여 전체 최적해를 구할 수 있는 경우를 의미한다.

최단 경로를 구해야 하는 상황에서는 모든 선택이 최단 거리일 때 전체 최단 거리가 된다. 

정리하자면, 그리디 알고리즘은 위의 두 조건을 만족하지 않으면 최적해를 보장할 수 없기 때문에 그리디 알고리즘으로 최적해를 구할 수 있는지 판단하여 사용하는 것이 중요하다.

## BOJ_1374 강의실

---

**접근법**

→ 프린터 대기열 같은 문제를 몇 번 풀어봐서 강의를 시작 시간 기준으로 봤을 때 종료 되는 강의가 있으면 제거하고 개수를 세면 될 거 같았다.

전체 강의 수 - 제거한 강의 = 필요한 강의실 개수

**시간복잡도**

→ O(nlogn)

우선순위 큐의 삽입과 삭제는 O(logn)의 시간복잡도를 가진다.

n개의 원소에 대해 lecture에 삽입이 1번, rooms에 삽입이 1번 되기 때문에 O(2nlogn)이라고 생각했다. 빅오표기법에 따라 O(nlogn)이 된다.

![KakaoTalk_20230503_020343543](https://user-images.githubusercontent.com/33473174/235738495-c9960b82-06a0-41eb-97d8-beb8f352649d.jpg)
